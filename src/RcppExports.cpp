// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <Rcpp.h>

using namespace Rcpp;

// confirm_CJMLE_MIRTb_cpp
Rcpp::List confirm_CJMLE_MIRTb_cpp(arma::mat response, arma::mat nonmis_ind, arma::mat theta0, arma::mat A0, arma::mat Q, double C, double tol);
RcppExport SEXP _biglfm_confirm_CJMLE_MIRTb_cpp(SEXP responseSEXP, SEXP nonmis_indSEXP, SEXP theta0SEXP, SEXP A0SEXP, SEXP QSEXP, SEXP CSEXP, SEXP tolSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type response(responseSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type nonmis_ind(nonmis_indSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type theta0(theta0SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type A0(A0SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type Q(QSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    rcpp_result_gen = Rcpp::wrap(confirm_CJMLE_MIRTb_cpp(response, nonmis_ind, theta0, A0, Q, C, tol));
    return rcpp_result_gen;
END_RCPP
}
// CJMLE_MIRT
Rcpp::List CJMLE_MIRT(const arma::mat& response, const arma::mat& nonmis_ind, arma::mat theta0, arma::mat A0, const arma::mat& Q, double C, double tol, bool parallel);
RcppExport SEXP _biglfm_CJMLE_MIRT(SEXP responseSEXP, SEXP nonmis_indSEXP, SEXP theta0SEXP, SEXP A0SEXP, SEXP QSEXP, SEXP CSEXP, SEXP tolSEXP, SEXP parallelSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type response(responseSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type nonmis_ind(nonmis_indSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type theta0(theta0SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type A0(A0SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< bool >::type parallel(parallelSEXP);
    rcpp_result_gen = Rcpp::wrap(CJMLE_MIRT(response, nonmis_ind, theta0, A0, Q, C, tol, parallel));
    return rcpp_result_gen;
END_RCPP
}
// neg_loglik_linear
double neg_loglik_linear(const arma::mat& thetaA, const arma::mat& response, double sigma_square);
RcppExport SEXP _biglfm_neg_loglik_linear(SEXP thetaASEXP, SEXP responseSEXP, SEXP sigma_squareSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type thetaA(thetaASEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type response(responseSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    rcpp_result_gen = Rcpp::wrap(neg_loglik_linear(thetaA, response, sigma_square));
    return rcpp_result_gen;
END_RCPP
}
// neg_loglik_linear_i_cpp
double neg_loglik_linear_i_cpp(const arma::vec& response_i, const arma::mat& A, const arma::vec& theta_i, double sigma_square);
RcppExport SEXP _biglfm_neg_loglik_linear_i_cpp(SEXP response_iSEXP, SEXP ASEXP, SEXP theta_iSEXP, SEXP sigma_squareSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type response_i(response_iSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type A(ASEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type theta_i(theta_iSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    rcpp_result_gen = Rcpp::wrap(neg_loglik_linear_i_cpp(response_i, A, theta_i, sigma_square));
    return rcpp_result_gen;
END_RCPP
}
// grad_neg_loglik_linear_thetai_cpp
arma::vec grad_neg_loglik_linear_thetai_cpp(const arma::vec& response_i, const arma::mat& A, const arma::vec& theta_i, double sigma_square);
RcppExport SEXP _biglfm_grad_neg_loglik_linear_thetai_cpp(SEXP response_iSEXP, SEXP ASEXP, SEXP theta_iSEXP, SEXP sigma_squareSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type response_i(response_iSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type A(ASEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type theta_i(theta_iSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    rcpp_result_gen = Rcpp::wrap(grad_neg_loglik_linear_thetai_cpp(response_i, A, theta_i, sigma_square));
    return rcpp_result_gen;
END_RCPP
}
// Update_theta_linear_cpp
arma::mat Update_theta_linear_cpp(const arma::mat& theta0, const arma::mat& response, const arma::mat& A0, double sigma_square, double C);
RcppExport SEXP _biglfm_Update_theta_linear_cpp(SEXP theta0SEXP, SEXP responseSEXP, SEXP A0SEXP, SEXP sigma_squareSEXP, SEXP CSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type theta0(theta0SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type response(responseSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type A0(A0SEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    rcpp_result_gen = Rcpp::wrap(Update_theta_linear_cpp(theta0, response, A0, sigma_square, C));
    return rcpp_result_gen;
END_RCPP
}
// neg_loglik_linear_j_cpp
double neg_loglik_linear_j_cpp(const arma::vec& response_j, const arma::vec& A_j, const arma::mat& theta, double sigma_square);
RcppExport SEXP _biglfm_neg_loglik_linear_j_cpp(SEXP response_jSEXP, SEXP A_jSEXP, SEXP thetaSEXP, SEXP sigma_squareSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type response_j(response_jSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type A_j(A_jSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    rcpp_result_gen = Rcpp::wrap(neg_loglik_linear_j_cpp(response_j, A_j, theta, sigma_square));
    return rcpp_result_gen;
END_RCPP
}
// grad_neg_loglik_linear_A_j_cpp
arma::vec grad_neg_loglik_linear_A_j_cpp(const arma::vec& response_j, const arma::vec& A_j, const arma::vec& Q_j, const arma::mat& theta, double sigma_square);
RcppExport SEXP _biglfm_grad_neg_loglik_linear_A_j_cpp(SEXP response_jSEXP, SEXP A_jSEXP, SEXP Q_jSEXP, SEXP thetaSEXP, SEXP sigma_squareSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type response_j(response_jSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type A_j(A_jSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type Q_j(Q_jSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    rcpp_result_gen = Rcpp::wrap(grad_neg_loglik_linear_A_j_cpp(response_j, A_j, Q_j, theta, sigma_square));
    return rcpp_result_gen;
END_RCPP
}
// Update_A_linear_cpp
arma::mat Update_A_linear_cpp(const arma::mat& A0, const arma::mat& Q, const arma::mat& response, const arma::mat& theta1, double sigma_square, double C);
RcppExport SEXP _biglfm_Update_A_linear_cpp(SEXP A0SEXP, SEXP QSEXP, SEXP responseSEXP, SEXP theta1SEXP, SEXP sigma_squareSEXP, SEXP CSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type A0(A0SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type response(responseSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type theta1(theta1SEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    rcpp_result_gen = Rcpp::wrap(Update_A_linear_cpp(A0, Q, response, theta1, sigma_square, C));
    return rcpp_result_gen;
END_RCPP
}
// CJMLE_linear
Rcpp::List CJMLE_linear(const arma::mat& response, arma::mat theta0, arma::mat A0, const arma::mat& Q, double sigma_square, double C, double tol, bool parallel);
RcppExport SEXP _biglfm_CJMLE_linear(SEXP responseSEXP, SEXP theta0SEXP, SEXP A0SEXP, SEXP QSEXP, SEXP sigma_squareSEXP, SEXP CSEXP, SEXP tolSEXP, SEXP parallelSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type response(responseSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type theta0(theta0SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type A0(A0SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_square(sigma_squareSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< bool >::type parallel(parallelSEXP);
    rcpp_result_gen = Rcpp::wrap(CJMLE_linear(response, theta0, A0, Q, sigma_square, C, tol, parallel));
    return rcpp_result_gen;
END_RCPP
}
// CJMLE_poisson
Rcpp::List CJMLE_poisson(const arma::mat& response, arma::mat theta0, arma::mat A0, const arma::mat& Q, double C, double tol, bool parallel);
RcppExport SEXP _biglfm_CJMLE_poisson(SEXP responseSEXP, SEXP theta0SEXP, SEXP A0SEXP, SEXP QSEXP, SEXP CSEXP, SEXP tolSEXP, SEXP parallelSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type response(responseSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type theta0(theta0SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type A0(A0SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< bool >::type parallel(parallelSEXP);
    rcpp_result_gen = Rcpp::wrap(CJMLE_poisson(response, theta0, A0, Q, C, tol, parallel));
    return rcpp_result_gen;
END_RCPP
}
// prox_func_cpp
arma::vec prox_func_cpp(arma::vec y, double C);
RcppExport SEXP _biglfm_prox_func_cpp(SEXP ySEXP, SEXP CSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::vec >::type y(ySEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    rcpp_result_gen = Rcpp::wrap(prox_func_cpp(y, C));
    return rcpp_result_gen;
END_RCPP
}
// myKendall_cpp
double myKendall_cpp(arma::vec x, arma::vec y);
RcppExport SEXP _biglfm_myKendall_cpp(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type y(ySEXP);
    rcpp_result_gen = Rcpp::wrap(myKendall_cpp(x, y));
    return rcpp_result_gen;
END_RCPP
}
// sample_A_func
arma::mat sample_A_func(int K, int J, double C, double frac);
RcppExport SEXP _biglfm_sample_A_func(SEXP KSEXP, SEXP JSEXP, SEXP CSEXP, SEXP fracSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type K(KSEXP);
    Rcpp::traits::input_parameter< int >::type J(JSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    Rcpp::traits::input_parameter< double >::type frac(fracSEXP);
    rcpp_result_gen = Rcpp::wrap(sample_A_func(K, J, C, frac));
    return rcpp_result_gen;
END_RCPP
}
// sample_theta_func
arma::mat sample_theta_func(int K, int N, double C, double frac);
RcppExport SEXP _biglfm_sample_theta_func(SEXP KSEXP, SEXP NSEXP, SEXP CSEXP, SEXP fracSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type K(KSEXP);
    Rcpp::traits::input_parameter< int >::type N(NSEXP);
    Rcpp::traits::input_parameter< double >::type C(CSEXP);
    Rcpp::traits::input_parameter< double >::type frac(fracSEXP);
    rcpp_result_gen = Rcpp::wrap(sample_theta_func(K, N, C, frac));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_biglfm_confirm_CJMLE_MIRTb_cpp", (DL_FUNC) &_biglfm_confirm_CJMLE_MIRTb_cpp, 7},
    {"_biglfm_CJMLE_MIRT", (DL_FUNC) &_biglfm_CJMLE_MIRT, 8},
    {"_biglfm_neg_loglik_linear", (DL_FUNC) &_biglfm_neg_loglik_linear, 3},
    {"_biglfm_neg_loglik_linear_i_cpp", (DL_FUNC) &_biglfm_neg_loglik_linear_i_cpp, 4},
    {"_biglfm_grad_neg_loglik_linear_thetai_cpp", (DL_FUNC) &_biglfm_grad_neg_loglik_linear_thetai_cpp, 4},
    {"_biglfm_Update_theta_linear_cpp", (DL_FUNC) &_biglfm_Update_theta_linear_cpp, 5},
    {"_biglfm_neg_loglik_linear_j_cpp", (DL_FUNC) &_biglfm_neg_loglik_linear_j_cpp, 4},
    {"_biglfm_grad_neg_loglik_linear_A_j_cpp", (DL_FUNC) &_biglfm_grad_neg_loglik_linear_A_j_cpp, 5},
    {"_biglfm_Update_A_linear_cpp", (DL_FUNC) &_biglfm_Update_A_linear_cpp, 6},
    {"_biglfm_CJMLE_linear", (DL_FUNC) &_biglfm_CJMLE_linear, 8},
    {"_biglfm_CJMLE_poisson", (DL_FUNC) &_biglfm_CJMLE_poisson, 7},
    {"_biglfm_prox_func_cpp", (DL_FUNC) &_biglfm_prox_func_cpp, 2},
    {"_biglfm_myKendall_cpp", (DL_FUNC) &_biglfm_myKendall_cpp, 2},
    {"_biglfm_sample_A_func", (DL_FUNC) &_biglfm_sample_A_func, 4},
    {"_biglfm_sample_theta_func", (DL_FUNC) &_biglfm_sample_theta_func, 4},
    {NULL, NULL, 0}
};

RcppExport void R_init_biglfm(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
